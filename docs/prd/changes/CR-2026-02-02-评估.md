# 评估模块需求变更文档

## 1. 需求变更概述

### 1.1 变更背景
本次需求变更针对评估模块进行功能迭代，主要涉及渠道名额和分数对比功能的优化，以及综合达成概率逻辑和样式的修改。

### 1.2 变更目标
- 优化渠道名额和分数对比功能，提供更清晰的差距分析
- 改进综合达成概率的展示方式，使用红黄绿信号灯机制
- 提升用户体验，使评估结果更加直观易懂

## 2. 现有功能分析

### 2.1 现有模块结构
- **EvalPage.tsx**：评估模块主页面，负责加载和展示评估数据
- **EvalTargetCard.tsx**：评估目标卡片组件，展示单个学校的评估信息
- **数据结构**：使用 `TargetEvaluationResponse`、`TargetEvaluationSchool` 等类型定义

### 2.2 现有功能逻辑
1. **数据获取**：通过 `getTargetEvaluation` API 获取评估数据
2. **展示逻辑**：
   - 显示学校基本信息和总体概率
   - 按渠道（自主招生、分配到区、分配到校、统一招生）展示详细信息
   - 每个渠道显示：分数、名额、差距、概率
3. **样式逻辑**：
   - 使用不同颜色表示概率等级（高、中、低）
   - 概率条使用对应的颜色标识

### 2.3 现有数据结构
```typescript
// 渠道评估数据结构
export interface TargetEvaluationChannel {
  score: number | null;      // 分数线
  quota: number | null;      // 名额
  probability: number | null; // 概率
  gap: number | null;        // 差距
}
```

## 3. 需求变更详情

### 3.1 渠道名额和分数对比功能

#### 3.1.1 字段顺序调整
**变更前**：渠道、分数、名额、差距、概率
**变更后**：渠道、名额、分数线、差距(最好)、差距（最差）、差距（平均）、状态

#### 3.1.2 差距字段优化
- **多模考情况**：显示三个差距值（最好、最差、平均）
- **单模考情况**：将三个差距替换为"模考差距"

#### 3.1.3 状态字段
- **显示方式**：红黄绿灯形式
- **判断逻辑**：
  - 差距5分以内：绿灯
  - 差距5-30分：黄灯
  - 差距20分以上：红灯（注：需求描述中20分和30分有冲突，建议统一为30分）

### 3.2 综合达成概率逻辑和样式修改

#### 3.2.1 逻辑修改
**变更前**：基于概率值计算等级（高、中、低）
**变更后**：基于渠道状态计算综合状态
- 只要有1个渠道状态为绿灯，综合状态显示绿灯
- 无绿灯但有黄灯，综合状态显示黄灯
- 其他情况显示红灯

#### 3.2.2 样式修改
- 使用红黄绿信号灯图标替代原有的文字和颜色标识
- 保持概率百分比的显示

## 4. 技术设计方案

### 4.1 数据结构修改

#### 4.1.1 TargetEvaluationChannel 扩展
```typescript
export interface TargetEvaluationChannel {
  score: number | null;          // 分数线
  quota: number | null;          // 名额
  probability: number | null;     // 概率
  gap: number | null;            // 原有差距字段
  gaps?: {
    best: number | null;         // 最好差距
    worst: number | null;        // 最差差距
    average: number | null;      // 平均差距
  };
  status?: 'green' | 'yellow' | 'red'; // 状态
}
```

#### 4.1.2 TargetEvaluationSchool 扩展
```typescript
export interface TargetEvaluationSchool {
  // 现有字段...
  overall: {
    probability: number | null;
    level: 'high' | 'mid' | 'low' | 'na';
    status?: 'green' | 'yellow' | 'red'; // 综合状态
  };
}
```

### 4.2 组件修改

#### 4.2.1 EvalTargetCard.tsx 修改
1. **表格结构调整**：
   - 调整表头顺序：渠道、名额、分数线、差距(最好)、差距（最差）、差距（平均）、状态
   - 单模考时显示"模考差距"替代三个差距字段

2. **状态计算逻辑**：
   - 实现差距状态计算函数
   - 实现综合状态计算函数

3. **样式修改**：
   - 添加红黄绿信号灯图标
   - 调整表格布局以适应新字段

#### 4.2.2 新增工具函数
- `calculateGapStatus(gap: number): 'green' | 'yellow' | 'red'`：计算差距状态
- `calculateOverallStatus(channels: TargetEvaluationChannel[]): 'green' | 'yellow' | 'red'`：计算综合状态

### 4.3 逻辑流程
1. **数据加载**：保持现有 `getTargetEvaluation` API 调用
2. **数据处理**：
   - 对每个渠道计算差距状态
   - 基于渠道状态计算综合状态
3. **UI渲染**：
   - 渲染调整后的表格结构
   - 显示信号灯状态

## 5. API接口方案

### 5.1 现有API
- **GET /schools/targets/evaluation**：获取目标学校评估数据

### 5.2 后端API升级方案

#### 5.2.1 数据结构扩展

**后端返回数据结构**：

```typescript
// API返回数据结构扩展
interface TargetEvaluationChannelResponse {
  score: number | null;          // 分数线
  quota: number | null;          // 名额
  probability: number | null;     // 概率
  gap: number | null;            // 原有差距字段
  gaps?: {
    best: number | null;         // 最好差距
    worst: number | null;        // 最差差距
    average: number | null;      // 平均差距
  };
  status?: 'green' | 'yellow' | 'red'; // 状态
}

interface TargetEvaluationSchoolResponse {
  id: string;
  name: string;
  district: string;
  type: string;
  fullType?: string;
  channels: {
    autonomous: TargetEvaluationChannelResponse;
    district: TargetEvaluationChannelResponse;
    school: TargetEvaluationChannelResponse;
    unified: TargetEvaluationChannelResponse;
  };
  overall: {
    probability: number | null;
    level: 'high' | 'mid' | 'low' | 'na';
    status?: 'green' | 'yellow' | 'red'; // 综合状态
  };
}

interface TargetEvaluationResponse {
  profile: {
    district: string | null;
    middleSchoolId: string | null;
    stableScore: number | null;
    highScore: number | null;
    lowScore: number | null;
  };
  model: {
    mean: number | null;
    std: number | null;
    count: number;
    source: string;
  };
  targets: TargetEvaluationSchoolResponse[];
}
```

#### 5.2.2 后端计算逻辑实现

**1. 差距计算逻辑**：

```python
def calculate_gaps(score: Optional[float], model: Dict[str, Any]) -> Dict[str, Optional[float]]:
    """计算差距的最好、最差、平均值"""
    mean = model.get("mean")
    if score is None or mean is None:
        return {"best": None, "worst": None, "average": None}
    
    # 基于模型的标准差计算差距范围
    std = model.get("std", 5.0)
    average_gap = round(mean - score, 1)
    best_gap = round(average_gap + std, 1)  # 最好情况：分数更高
    worst_gap = round(average_gap - std, 1)  # 最差情况：分数更低
    
    return {
        "best": best_gap,
        "worst": worst_gap,
        "average": average_gap
    }
```

**2. 状态计算逻辑**：

```python
def calculate_gap_status(gap: Optional[float]) -> Optional[str]:
    """根据差距值计算状态"""
    if gap is None:
        return None
    if gap >= -5:  # 差距5分以内（包括正差距和小负差距）
        return "green"
    elif gap >= -30:  # 差距5-30分
        return "yellow"
    else:  # 差距30分以上
        return "red"
```

**3. 综合状态计算逻辑**：

```python
def calculate_overall_status(channels: Dict[str, Dict[str, Any]]) -> str:
    """根据渠道状态计算综合状态"""
    # 收集所有渠道的状态
    channel_statuses = []
    for channel_key, channel_data in channels.items():
        status = channel_data.get("status")
        if status:
            channel_statuses.append(status)
    
    if not channel_statuses:
        return "red"  # 无状态信息时默认为红灯
    
    # 只要有一个绿灯，综合状态为绿灯
    if "green" in channel_statuses:
        return "green"
    # 无绿灯但有黄灯，综合状态为黄灯
    elif "yellow" in channel_statuses:
        return "yellow"
    # 其他情况为红灯
    else:
        return "red"
```

**4. 评估数据构建逻辑修改**：

```python
def build_target_evaluations(
    enriched_schools: List[Dict[str, Any]],
    model: Dict[str, Any],
) -> List[Dict[str, Any]]:
    mean = model.get("mean")
    std = model.get("std")
    evaluations: List[Dict[str, Any]] = []
    
    for school in enriched_schools:
        stats = school.get("stats") or {}
        unified_score = safe_float(stats.get("scoreUnified"))
        district_score = safe_float(stats.get("scoreToDistrict"))
        school_score = safe_float(stats.get("scoreToSchool"))
        autonomous_quota = safe_int(stats.get("quotaAutonomous"))
        district_quota = safe_int(stats.get("quotaToDistrict"))
        school_quota = safe_int(stats.get("quotaToSchool"))

        unified_prob = probability_to_reach(unified_score, mean, std)
        district_prob = probability_to_reach(district_score, mean, std)
        school_prob = probability_to_reach(school_score, mean, std)

        available_probs = [p for p in [unified_prob, district_prob, school_prob] if p is not None]
        overall_prob = None
        if available_probs:
            product = 1.0
            for p in available_probs:
                product *= (1 - p)
            overall_prob = clamp(1 - product, 0.0, 1.0)
        
        # 计算各渠道的差距和状态
        channels = {
            "autonomous": {
                "score": None,
                "quota": autonomous_quota,
                "probability": None,
                "gap": None,
                "gaps": None,
                "status": None,
            },
            "district": {
                "score": district_score,
                "quota": district_quota,
                "probability": district_prob,
                "gap": None if district_score is None or mean is None else round(mean - district_score, 1),
                "gaps": calculate_gaps(district_score, model),
                "status": None,
            },
            "school": {
                "score": school_score,
                "quota": school_quota,
                "probability": school_prob,
                "gap": None if school_score is None or mean is None else round(mean - school_score, 1),
                "gaps": calculate_gaps(school_score, model),
                "status": None,
            },
            "unified": {
                "score": unified_score,
                "quota": None,
                "probability": unified_prob,
                "gap": None if unified_score is None or mean is None else round(mean - unified_score, 1),
                "gaps": calculate_gaps(unified_score, model),
                "status": None,
            },
        }
        
        # 为每个渠道计算状态
        for channel_key, channel_data in channels.items():
            # 使用平均差距计算状态
            gap_value = channel_data.get("gaps", {}).get("average") or channel_data.get("gap")
            channels[channel_key]["status"] = calculate_gap_status(gap_value)
        
        # 计算综合状态
        overall_status = calculate_overall_status(channels)
        
        evaluations.append(
            {
                "id": school.get("id"),
                "name": school.get("name"),
                "district": school.get("district"),
                "type": school.get("type"),
                "fullType": school.get("fullType"),
                "channels": channels,
                "overall": {
                    "probability": overall_prob,
                    "level": level_from_probability(overall_prob),
                    "status": overall_status,
                },
            }
        )

    return evaluations
```

#### 5.2.3 单模考情况处理

**后端逻辑**：

```python
def is_single_mock_situation(model: Dict[str, Any]) -> bool:
    """判断是否为单模考情况"""
    # 基于模型信息判断
    return model.get("source") == "mocks" and model.get("count") == 1

# 在构建评估数据时
if is_single_mock_situation(model):
    # 单模考情况：直接使用gap字段作为模考差距
    for channel_key, channel_data in channels.items():
        if channel_data.get("gap") is not None:
            # 单模考时，gaps字段设置为与gap相同的值
            channels[channel_key]["gaps"] = {
                "best": channel_data["gap"],
                "worst": channel_data["gap"],
                "average": channel_data["gap"]
            }
```

### 5.3 前端处理

#### 5.3.1 数据适配

**前端接收数据后**：

```typescript
// 处理单模考情况的显示
const isSingleMock = model.source === 'mocks' && model.count === 1;

// 渲染差距字段
if (isSingleMock) {
  // 显示"模考差距"
  <div>{channel.gaps?.average ?? '-'}</div>
} else {
  // 显示三个差距值
  <div>{channel.gaps?.best ?? '-'}</div>
  <div>{channel.gaps?.worst ?? '-'}</div>
  <div>{channel.gaps?.average ?? '-'}</div>
}

// 渲染状态字段
const statusIcon = {
  green: '🟢',
  yellow: '🟡',
  red: '🔴'
}[channel.status || 'red'];
```

#### 5.3.2 兼容性处理

如果后端API暂时无法提供完整的差距数据，前端可以：
1. **基于现有gap字段计算状态**：使用 `calculate_gap_status` 函数计算状态
2. **模拟差距数据**：对于多模考情况，基于现有gap和标准差模拟最好、最差差距
3. **逐步过渡**：先实现状态显示，待后端API就绪后再实现完整的差距分析

### 5.4 API性能优化

#### 5.4.1 计算优化

1. **批量计算**：在后端一次性计算所有学校的评估数据，减少重复计算
2. **缓存机制**：对于频繁请求的评估数据，考虑添加缓存
3. **异步处理**：对于复杂的计算逻辑，考虑使用异步处理

#### 5.4.2 数据传输优化

1. **字段精简**：只返回前端需要的字段，减少数据传输量
2. **压缩传输**：启用HTTP压缩，减少网络传输时间
3. **分页处理**：如果目标学校数量较多，考虑实现分页机制

## 6. UI修改方案

### 6.1 信号灯图标设计
- **绿灯**：🟢 或绿色圆形图标
- **黄灯**：🟡 或黄色圆形图标
- **红灯**：🔴 或红色圆形图标

### 6.2 表格布局调整
1. **表头样式**：保持现有样式，调整字段顺序
2. **数据行样式**：
   - 状态列显示对应颜色的信号灯图标
   - 差距字段根据正负值显示不同颜色（正：绿色，负：红色）

### 6.3 综合状态显示
- 在学校名称旁边显示综合状态信号灯
- 保持现有概率百分比显示

### 6.4 响应式设计
- 确保在不同屏幕尺寸下表格内容正常显示
- 小屏幕设备可能需要横向滚动

## 7. 实现计划

### 7.1 前端实现
1. **数据结构调整**：扩展类型定义，适配后端新的数据结构
2. **工具函数实现**：添加状态计算函数（备用方案）
3. **组件修改**：调整 EvalTargetCard 组件，实现新的表格结构和状态显示
4. **样式优化**：添加信号灯图标和调整布局
5. **数据适配**：处理单模考和多模考情况的显示逻辑

### 7.2 后端实现
1. **API扩展**：修改评估数据返回结构，添加 gaps 和 status 字段
2. **逻辑实现**：
   - 实现 `calculate_gaps` 函数，计算最好、最差、平均差距
   - 实现 `calculate_gap_status` 函数，计算差距状态
   - 实现 `calculate_overall_status` 函数，计算综合状态
   - 修改 `build_target_evaluations` 函数，集成新的计算逻辑
3. **单模考处理**：实现 `is_single_mock_situation` 函数，处理单模考情况
4. **性能优化**：添加批量计算和缓存机制

### 7.3 测试计划
- 测试单模考情况的显示
- 测试多模考情况的显示
- 测试不同差距值的状态显示
- 测试综合状态计算逻辑
- 测试响应式布局

## 8. 风险评估

### 8.1 潜在风险
1. **API数据结构不匹配**：如果后端无法及时提供扩展的数据结构，前端可能需要临时处理
2. **需求冲突**：状态判断逻辑中20分和30分的阈值冲突需要确认
3. **响应式布局**：小屏幕设备可能出现表格显示问题

### 8.2 应对策略
1. **前端兼容处理**：设计兼容现有数据结构的前端逻辑
2. **需求确认**：及时与产品确认状态判断的准确阈值
3. **响应式优化**：针对小屏幕设备进行特殊处理

## 9. 结论

本次需求变更将显著提升评估模块的用户体验，通过更清晰的差距分析和直观的信号灯状态显示，帮助用户更好地理解评估结果。技术实现上，主要涉及前端组件的调整和数据结构的扩展，后端可能需要相应调整API返回结构以支持新字段。

建议按照实现计划逐步推进，确保功能的正确性和用户体验的一致性。